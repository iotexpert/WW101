/***************************************************************************//**
* \file     ADC.c
* \version  1.20
*
* \brief
* Provides the source code to the API for the ADC Component.
*
********************************************************************************
* \copyright
* (c) 2015-2016, Cypress Semiconductor Corporation. All rights reserved.
* This software, including source code, documentation and related
* materials ("Software"), is owned by Cypress Semiconductor
* Corporation ("Cypress") and is protected by and subject to worldwide
* patent protection (United States and foreign), United States copyright
* laws and international treaty provisions. Therefore, you may use this
* Software only as provided in the license agreement accompanying the
* software package from which you obtained this Software ("EULA").
* If no EULA applies, Cypress hereby grants you a personal, nonexclusive,
* non-transferable license to copy, modify, and compile the
* Software source code solely for use in connection with Cypress's
* integrated circuit products. Any reproduction, modification, translation,
* compilation, or representation of this Software except as specified
* above is prohibited without the express written permission of Cypress.
* Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO
* WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING,
* BUT NOT LIMITED TO, NONINFRINGEMENT, IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
* PARTICULAR PURPOSE. Cypress reserves the right to make
* changes to the Software without notice. Cypress does not assume any
* liability arising out of the application or use of the Software or any
* product or circuit described in the Software. Cypress does not
* authorize its products for use in any products where a malfunction or
* failure of the Cypress product may reasonably be expected to result in
* significant property damage, injury or death ("High Risk Product"). By
* including Cypress's product in a High Risk Product, the manufacturer
* of such system or application assumes all risk of such use and in doing
* so agrees to indemnify Cypress against all liability.
*******************************************************************************/
#include "ADC.h"

#include <stdlib.h>

static int32 ADC_IsChannelSigned(uint32 chan);
#if(ADC_ANY_CONFIG_USES_FILTER	!= 0u)
static void ADC_SetupComparatorTrim(void);
static void ADC_UndoComparatorTrimSetup(void);
static uint32 ADC_RaiseOpampTrimToCrossing(uint32 startTrim);
static uint32 ADC_LowerOpampTrimToCrossing(uint32 startTrim);
static uint32 ADC_RaiseAgndTrimToCrossing(uint32 startTrim);
static uint32 ADC_LowerAgndTrimToCrossing(uint32 startTrim);
static uint32 ADC_SetOpampAndAgndTrim(uint32 opampTrim, uint32 agndTrim);
static uint32 ADC_SetOpampTrim(uint32 opampTrim);
static uint32 ADC_SetAgndTrim(uint32 agndTrim);
static uint32 ADC_IncOpampTrim(uint32 trim);
static uint32 ADC_DecOpampTrim(uint32 trim);
static uint32 ADC_IncAgndTrim(uint32 trim);
static uint32 ADC_DecAgndTrim(uint32 trim);
#define OFFSET_SAMPLES (30)
#endif

uint8 ADC_initVar = 0u; 

uint8 ADC_selected = 0u; /* 0 if no configuration selected. 1 otherwise. */
volatile int16 ADC_offset[ADC_TOTAL_CHANNELS_NUM]; 
volatile int32 ADC_countsPer10Volt[ADC_TOTAL_CHANNELS_NUM]; 

static uint32 ADC_currentConfig = 0u; /* Currently active configuration */

/*******************************************************************************
* Local data allocation
*******************************************************************************/
/* Channels configuration generated by customiser */
static const uint32 CYCODE ADC_channelsConfig[] = { 0x00000100UL, 0x00001100UL,  };

/* Filter init */
#if(ADC_ANY_CONFIG_USES_FILTER	!= 0u)
    #if (0u != ADC_CFG0_FILTER_PRESENT)
        #define ADC_CFG0_UABH_A_FILTER_INITPAIRSSIZE ((ADC_CFG0_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 18u \
                                                             : 18u)
        static CyUAB_reg_pair ADC_CFG0_UABH_A_FILTER_initPairs[ADC_CFG0_UABH_A_FILTER_INITPAIRSSIZE] =
        {
        	/*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_UABH_A_OA_CTRL_PTR        , ((uint32)ADC_UABH_A_DEFAULT_OA_CTRL)}
            ,{ADC_UABH_A_SW_STATIC_PTR      , ((uint32)ADC_UABH_A_DEFAULT_SW_STATIC)}
            ,{ADC_UABH_A_SW_MODBIT_SRC_PTR      , ((uint32)ADC_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{ADC_UABH_A_SRAM_CTRL_PTR      , ((uint32)ADC_UABH_A_INVAR_SRAM_CTRL)} 
            ,{ADC_UABH_A_STARTUP_DELAY_PTR  , ((uint32)ADC_CFG0_UABH_A_STARTUP_DELAY)}
            ,{ADC_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)ADC_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_UABH_A_SW_OTHER_PTR  , ((uint32)ADC_UABH_A_DEFAULT_SW_OTHER)}
            
            #if (ADC_CFG0_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{ADC_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_CFG0_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{ADC_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_CFG0_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{ADC_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_CFG0_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{ADC_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_CFG0_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{ADC_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_CFG0_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{ADC_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG0_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_CFG0_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{ADC_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{ADC_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_CFG0_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{ADC_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_CFG0_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG0_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (ADC_CFG0_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) */
        };

        #define ADC_CFG0_UABH_B_FILTER_INITPAIRSSIZE ((ADC_CFG0_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 19u \
                                                             : 19u)
        static CyUAB_reg_pair ADC_CFG0_UABH_B_FILTER_initPairs[ADC_CFG0_UABH_B_FILTER_INITPAIRSSIZE] = 
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_UABH_B_OA_CTRL_PTR        , ((uint32)ADC_UABH_B_DEFAULT_OA_CTRL)}
            ,{ADC_UABH_B_SW_STATIC_PTR      , ((uint32)ADC_UABH_B_DEFAULT_SW_STATIC)}
            ,{ADC_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)ADC_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{ADC_UABH_B_SRAM_CTRL_PTR      , ((uint32)ADC_UABH_B_INVAR_SRAM_CTRL)} 
            ,{ADC_UABH_B_STARTUP_DELAY_PTR  , ((uint32)ADC_CFG0_UABH_B_STARTUP_DELAY)}
            ,{ADC_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)ADC_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_UABH_B_SW_OTHER_PTR  , ((uint32)ADC_UABH_B_DEFAULT_SW_OTHER)}
            
            #if (ADC_CFG0_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q)
                    	/* Filter-invariant registers */
                ,{ADC_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{ADC_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{ADC_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{ADC_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{ADC_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{ADC_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_CFG0_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{ADC_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_CFG0_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{ADC_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG0_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_CFG0_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_HIGH_Q)
            	/* Filter-invariant registers */
                ,{ADC_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{ADC_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{ADC_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_CFG0_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{ADC_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_CFG0_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_CFG0_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{ADC_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG0_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (ADC_CFG0_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) */
        };

        static CyUAB_config ADC_CFG0_UABH_A_FILTER_config = {
            ADC_UABH_A_waveConfig,
            ADC_CFG0_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(ADC_UABH_A_PARAM_REF_TIED,ADC_UABH_A_PARAM_AGND_TIED,
                ADC_UABH_A_PARAM_SW_CC,ADC_UABH_A_PARAM_SW_BB,ADC_UABH_A_PARAM_SW_AA),
            ADC_UABH_A_NUM_STEPS,
            (uint8)(ADC_UABH_A_ELEMENT_COUNT(ADC_CFG0_UABH_A_FILTER_initPairs))
        };

        static CyUAB_config ADC_CFG0_UABH_B_FILTER_config = {
        ADC_UABH_B_waveConfig,
        ADC_CFG0_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(ADC_UABH_B_PARAM_REF_TIED,ADC_UABH_B_PARAM_AGND_TIED,
            ADC_UABH_B_PARAM_SW_CC,ADC_UABH_B_PARAM_SW_BB,ADC_UABH_B_PARAM_SW_AA),
        ADC_UABH_B_NUM_STEPS,
        (uint8)(ADC_UABH_B_ELEMENT_COUNT(ADC_CFG0_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != ADC_CFG0_FILTER_PRESENT) */
    #if (0u != ADC_CFG1_FILTER_PRESENT)
        #define ADC_CFG1_UABH_A_FILTER_INITPAIRSSIZE ((ADC_CFG1_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 18u \
                                                             : 18u)
        static CyUAB_reg_pair ADC_CFG1_UABH_A_FILTER_initPairs[ADC_CFG1_UABH_A_FILTER_INITPAIRSSIZE] =
        {
        	/*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_UABH_A_OA_CTRL_PTR        , ((uint32)ADC_UABH_A_DEFAULT_OA_CTRL)}
            ,{ADC_UABH_A_SW_STATIC_PTR      , ((uint32)ADC_UABH_A_DEFAULT_SW_STATIC)}
            ,{ADC_UABH_A_SW_MODBIT_SRC_PTR      , ((uint32)ADC_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{ADC_UABH_A_SRAM_CTRL_PTR      , ((uint32)ADC_UABH_A_INVAR_SRAM_CTRL)} 
            ,{ADC_UABH_A_STARTUP_DELAY_PTR  , ((uint32)ADC_CFG1_UABH_A_STARTUP_DELAY)}
            ,{ADC_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)ADC_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_UABH_A_SW_OTHER_PTR  , ((uint32)ADC_UABH_A_DEFAULT_SW_OTHER)}
            
            #if (ADC_CFG1_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{ADC_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_CFG1_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{ADC_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_CFG1_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{ADC_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_CFG1_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{ADC_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_CFG1_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{ADC_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_CFG1_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{ADC_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG1_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_CFG1_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{ADC_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{ADC_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_CFG1_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{ADC_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_CFG1_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG1_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (ADC_CFG1_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) */
        };

        #define ADC_CFG1_UABH_B_FILTER_INITPAIRSSIZE ((ADC_CFG1_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 19u \
                                                             : 19u)
        static CyUAB_reg_pair ADC_CFG1_UABH_B_FILTER_initPairs[ADC_CFG1_UABH_B_FILTER_INITPAIRSSIZE] = 
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_UABH_B_OA_CTRL_PTR        , ((uint32)ADC_UABH_B_DEFAULT_OA_CTRL)}
            ,{ADC_UABH_B_SW_STATIC_PTR      , ((uint32)ADC_UABH_B_DEFAULT_SW_STATIC)}
            ,{ADC_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)ADC_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{ADC_UABH_B_SRAM_CTRL_PTR      , ((uint32)ADC_UABH_B_INVAR_SRAM_CTRL)} 
            ,{ADC_UABH_B_STARTUP_DELAY_PTR  , ((uint32)ADC_CFG1_UABH_B_STARTUP_DELAY)}
            ,{ADC_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)ADC_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_UABH_B_SW_OTHER_PTR  , ((uint32)ADC_UABH_B_DEFAULT_SW_OTHER)}
            
            #if (ADC_CFG1_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q)
                    	/* Filter-invariant registers */
                ,{ADC_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{ADC_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{ADC_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{ADC_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{ADC_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{ADC_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_CFG1_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{ADC_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_CFG1_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{ADC_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG1_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_CFG1_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_HIGH_Q)
            	/* Filter-invariant registers */
                ,{ADC_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{ADC_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{ADC_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_CFG1_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{ADC_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_CFG1_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_CFG1_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{ADC_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG1_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (ADC_CFG1_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) */
        };

        static CyUAB_config ADC_CFG1_UABH_A_FILTER_config = {
            ADC_UABH_A_waveConfig,
            ADC_CFG1_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(ADC_UABH_A_PARAM_REF_TIED,ADC_UABH_A_PARAM_AGND_TIED,
                ADC_UABH_A_PARAM_SW_CC,ADC_UABH_A_PARAM_SW_BB,ADC_UABH_A_PARAM_SW_AA),
            ADC_UABH_A_NUM_STEPS,
            (uint8)(ADC_UABH_A_ELEMENT_COUNT(ADC_CFG1_UABH_A_FILTER_initPairs))
        };

        static CyUAB_config ADC_CFG1_UABH_B_FILTER_config = {
        ADC_UABH_B_waveConfig,
        ADC_CFG1_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(ADC_UABH_B_PARAM_REF_TIED,ADC_UABH_B_PARAM_AGND_TIED,
            ADC_UABH_B_PARAM_SW_CC,ADC_UABH_B_PARAM_SW_BB,ADC_UABH_B_PARAM_SW_AA),
        ADC_UABH_B_NUM_STEPS,
        (uint8)(ADC_UABH_B_ELEMENT_COUNT(ADC_CFG1_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != ADC_CFG1_FILTER_PRESENT) */
    #if (0u != ADC_CFG2_FILTER_PRESENT)
        #define ADC_CFG2_UABH_A_FILTER_INITPAIRSSIZE ((ADC_CFG2_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 18u \
                                                             : 18u)
        static CyUAB_reg_pair ADC_CFG2_UABH_A_FILTER_initPairs[ADC_CFG2_UABH_A_FILTER_INITPAIRSSIZE] =
        {
        	/*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_UABH_A_OA_CTRL_PTR        , ((uint32)ADC_UABH_A_DEFAULT_OA_CTRL)}
            ,{ADC_UABH_A_SW_STATIC_PTR      , ((uint32)ADC_UABH_A_DEFAULT_SW_STATIC)}
            ,{ADC_UABH_A_SW_MODBIT_SRC_PTR      , ((uint32)ADC_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{ADC_UABH_A_SRAM_CTRL_PTR      , ((uint32)ADC_UABH_A_INVAR_SRAM_CTRL)} 
            ,{ADC_UABH_A_STARTUP_DELAY_PTR  , ((uint32)ADC_CFG2_UABH_A_STARTUP_DELAY)}
            ,{ADC_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)ADC_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_UABH_A_SW_OTHER_PTR  , ((uint32)ADC_UABH_A_DEFAULT_SW_OTHER)}
            
            #if (ADC_CFG2_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{ADC_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_CFG2_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{ADC_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_CFG2_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{ADC_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_CFG2_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{ADC_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_CFG2_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{ADC_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_CFG2_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{ADC_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG2_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_CFG2_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{ADC_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{ADC_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_CFG2_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{ADC_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_CFG2_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG2_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (ADC_CFG2_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) */
        };

        #define ADC_CFG2_UABH_B_FILTER_INITPAIRSSIZE ((ADC_CFG2_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 19u \
                                                             : 19u)
        static CyUAB_reg_pair ADC_CFG2_UABH_B_FILTER_initPairs[ADC_CFG2_UABH_B_FILTER_INITPAIRSSIZE] = 
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_UABH_B_OA_CTRL_PTR        , ((uint32)ADC_UABH_B_DEFAULT_OA_CTRL)}
            ,{ADC_UABH_B_SW_STATIC_PTR      , ((uint32)ADC_UABH_B_DEFAULT_SW_STATIC)}
            ,{ADC_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)ADC_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{ADC_UABH_B_SRAM_CTRL_PTR      , ((uint32)ADC_UABH_B_INVAR_SRAM_CTRL)} 
            ,{ADC_UABH_B_STARTUP_DELAY_PTR  , ((uint32)ADC_CFG2_UABH_B_STARTUP_DELAY)}
            ,{ADC_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)ADC_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_UABH_B_SW_OTHER_PTR  , ((uint32)ADC_UABH_B_DEFAULT_SW_OTHER)}
            
            #if (ADC_CFG2_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q)
                    	/* Filter-invariant registers */
                ,{ADC_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{ADC_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{ADC_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{ADC_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{ADC_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{ADC_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_CFG2_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{ADC_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_CFG2_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{ADC_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG2_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_CFG2_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_HIGH_Q)
            	/* Filter-invariant registers */
                ,{ADC_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{ADC_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{ADC_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_CFG2_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{ADC_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_CFG2_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_CFG2_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{ADC_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG2_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (ADC_CFG2_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) */
        };

        static CyUAB_config ADC_CFG2_UABH_A_FILTER_config = {
            ADC_UABH_A_waveConfig,
            ADC_CFG2_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(ADC_UABH_A_PARAM_REF_TIED,ADC_UABH_A_PARAM_AGND_TIED,
                ADC_UABH_A_PARAM_SW_CC,ADC_UABH_A_PARAM_SW_BB,ADC_UABH_A_PARAM_SW_AA),
            ADC_UABH_A_NUM_STEPS,
            (uint8)(ADC_UABH_A_ELEMENT_COUNT(ADC_CFG2_UABH_A_FILTER_initPairs))
        };

        static CyUAB_config ADC_CFG2_UABH_B_FILTER_config = {
        ADC_UABH_B_waveConfig,
        ADC_CFG2_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(ADC_UABH_B_PARAM_REF_TIED,ADC_UABH_B_PARAM_AGND_TIED,
            ADC_UABH_B_PARAM_SW_CC,ADC_UABH_B_PARAM_SW_BB,ADC_UABH_B_PARAM_SW_AA),
        ADC_UABH_B_NUM_STEPS,
        (uint8)(ADC_UABH_B_ELEMENT_COUNT(ADC_CFG2_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != ADC_CFG2_FILTER_PRESENT) */
    #if (0u != ADC_CFG3_FILTER_PRESENT)
        #define ADC_CFG3_UABH_A_FILTER_INITPAIRSSIZE ((ADC_CFG3_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 18u \
                                                             : 18u)
        static CyUAB_reg_pair ADC_CFG3_UABH_A_FILTER_initPairs[ADC_CFG3_UABH_A_FILTER_INITPAIRSSIZE] =
        {
        	/*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_UABH_A_OA_CTRL_PTR        , ((uint32)ADC_UABH_A_DEFAULT_OA_CTRL)}
            ,{ADC_UABH_A_SW_STATIC_PTR      , ((uint32)ADC_UABH_A_DEFAULT_SW_STATIC)}
            ,{ADC_UABH_A_SW_MODBIT_SRC_PTR      , ((uint32)ADC_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{ADC_UABH_A_SRAM_CTRL_PTR      , ((uint32)ADC_UABH_A_INVAR_SRAM_CTRL)} 
            ,{ADC_UABH_A_STARTUP_DELAY_PTR  , ((uint32)ADC_CFG3_UABH_A_STARTUP_DELAY)}
            ,{ADC_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)ADC_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_UABH_A_SW_OTHER_PTR  , ((uint32)ADC_UABH_A_DEFAULT_SW_OTHER)}
            
            #if (ADC_CFG3_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{ADC_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_CFG3_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{ADC_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_CFG3_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{ADC_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_CFG3_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{ADC_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_CFG3_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{ADC_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_CFG3_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{ADC_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG3_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_CFG3_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{ADC_UABH_A_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_A_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_A_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_UABH_A_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_UABH_A_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_A_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_A_SW_CC_TOP_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{ADC_UABH_A_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{ADC_UABH_A_CAP_CTRL_PTR       , ((uint32)ADC_CFG3_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{ADC_UABH_A_SW_CB_TOP_PTR      , ((uint32)ADC_CFG3_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG3_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (ADC_CFG3_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) */
        };

        #define ADC_CFG3_UABH_B_FILTER_INITPAIRSSIZE ((ADC_CFG3_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 19u \
                                                             : 19u)
        static CyUAB_reg_pair ADC_CFG3_UABH_B_FILTER_initPairs[ADC_CFG3_UABH_B_FILTER_INITPAIRSSIZE] = 
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {ADC_UABH_B_OA_CTRL_PTR        , ((uint32)ADC_UABH_B_DEFAULT_OA_CTRL)}
            ,{ADC_UABH_B_SW_STATIC_PTR      , ((uint32)ADC_UABH_B_DEFAULT_SW_STATIC)}
            ,{ADC_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)ADC_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{ADC_UABH_B_SRAM_CTRL_PTR      , ((uint32)ADC_UABH_B_INVAR_SRAM_CTRL)} 
            ,{ADC_UABH_B_STARTUP_DELAY_PTR  , ((uint32)ADC_CFG3_UABH_B_STARTUP_DELAY)}
            ,{ADC_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)ADC_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{ADC_UABH_B_SW_OTHER_PTR  , ((uint32)ADC_UABH_B_DEFAULT_SW_OTHER)}
            
            #if (ADC_CFG3_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q)
                    	/* Filter-invariant registers */
                ,{ADC_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{ADC_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{ADC_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{ADC_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{ADC_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_B_LOWQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{ADC_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_CFG3_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{ADC_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_CFG3_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{ADC_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG3_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (ADC_CFG3_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_HIGH_Q)
            	/* Filter-invariant registers */
                ,{ADC_UABH_B_SW_CA_IN0_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{ADC_UABH_B_SW_CA_IN1_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{ADC_UABH_B_SW_CA_TOP_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{ADC_UABH_B_SW_CB_IN0_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{ADC_UABH_B_SW_CB_IN1_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{ADC_UABH_B_SW_CC_IN0_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{ADC_UABH_B_SW_CC_IN1_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{ADC_UABH_B_SW_CF_BOT_PTR      , ((uint32)ADC_UABH_B_HIGHQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{ADC_UABH_B_CAP_CTRL_PTR       , ((uint32)ADC_CFG3_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{ADC_UABH_B_SW_CB_TOP_PTR      , ((uint32)ADC_CFG3_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{ADC_UABH_B_SW_CC_TOP_PTR      , ((uint32)ADC_CFG3_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{ADC_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)ADC_CFG3_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (ADC_CFG3_FILTERTYPE_USED == ADC_FILTERTOPOLOGY_LOW_Q) */
        };

        static CyUAB_config ADC_CFG3_UABH_A_FILTER_config = {
            ADC_UABH_A_waveConfig,
            ADC_CFG3_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(ADC_UABH_A_PARAM_REF_TIED,ADC_UABH_A_PARAM_AGND_TIED,
                ADC_UABH_A_PARAM_SW_CC,ADC_UABH_A_PARAM_SW_BB,ADC_UABH_A_PARAM_SW_AA),
            ADC_UABH_A_NUM_STEPS,
            (uint8)(ADC_UABH_A_ELEMENT_COUNT(ADC_CFG3_UABH_A_FILTER_initPairs))
        };

        static CyUAB_config ADC_CFG3_UABH_B_FILTER_config = {
        ADC_UABH_B_waveConfig,
        ADC_CFG3_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(ADC_UABH_B_PARAM_REF_TIED,ADC_UABH_B_PARAM_AGND_TIED,
            ADC_UABH_B_PARAM_SW_CC,ADC_UABH_B_PARAM_SW_BB,ADC_UABH_B_PARAM_SW_AA),
        ADC_UABH_B_NUM_STEPS,
        (uint8)(ADC_UABH_B_ELEMENT_COUNT(ADC_CFG3_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != ADC_CFG3_FILTER_PRESENT) */
    
    
#endif /* (ADC_ANY_CONFIG_USES_FILTER	!= 0u)	*/

/*******************************************************************************
* Function Name: ADC_Start
****************************************************************************//**
*
* \brief Performs all required initialization for this component and enables the 
*  power. The power will be set to the appropriate power based on the clock 
*  frequency.
* 
* \param None
* 
* \return None
* 
* \sideeffect None
*
* \globalvars
*  \ref ADC_initVar (RW)
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_Start
*
*******************************************************************************/
void ADC_Start(void)
{
    if (ADC_INIT_VAR_INIT_FLAG != (ADC_INIT_VAR_INIT_FLAG & ADC_initVar))
    {
        ADC_Init();
        ADC_initVar |= ADC_INIT_VAR_INIT_FLAG;
    }
    
    ADC_Enable();
    
    return;
}

/*******************************************************************************
* Function Name: ADC_StartEx
****************************************************************************//**
*
* \brief This function starts the ADC and sets the Interrupt 
* Service Routine to the provided address using the 
* ADC_IRQ_StartEx() function. Refer to the Interrupt component 
* datasheet for more information on the ADC_IRQ_StartEx() function.
* 
* \param address This is the address of a user defined function for the ISR.
* 
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_StartEx
*
*******************************************************************************/
void ADC_StartEx(cyisraddress address)
{
    ADC_Start();
    ADC_IRQ_StartEx(address);
    return;
}

/*******************************************************************************
* Function Name: ADC_Stop
****************************************************************************//**
*
* \brief This function stops ADC conversions and puts the ADC into its lowest 
* power mode.
* 
* \param None
* 
* \return None
* 
* \sideeffect
* Do not use the ADC_Stop() API to halt conversions. Instead use the 
* ADC_StopConvert() API. If you use the ADC_Stop() API 
* to halt conversions then later use the ADC_Start() and 
* ADC_StartConvert() APIs to resume conversions, the first channel 
* of the scan may be corrupt. The ADC_StopConvert() API will enable 
* the ADC to complete the current scan of channels. After the 
* channel scan is complete, the ADC will stop all conversions, which 
* can be detected by the use of an ISR or the ADC_IsEndConversion() 
* flag.
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_Stop
*
*******************************************************************************/
void ADC_Stop(void)
{	
    #if(0u != ADC_ANY_CONFIG_USES_FILTER)	
    	if((ADC_allConfigs[ADC_currentConfig].miscConfig 
    	   & ADC_MISC_CONFIG_FILTER_PRESENT_MSK) 
    	   == ADC_MISC_CONFIG_FILTER_PRESENT_MSK)
    	{
    		ADC_UABH_A_Stop();
    		ADC_UABH_B_Stop();
            ADC_FILTERAGND2SAR_BUFFER_Stop();
    	}
    #endif /* ADC_ANY_CONFIG_USES_FILTER != 0u */
    ADC_SAR_CTRL_REG &= (uint32)~ADC_SAR_CTRL_ENABLED_MSK;
    return;
}

/* ****************************************************************************
* Function Name: ADC_InitConfig
****************************************************************************//*
*
* \brief Configures all of the registers for a given configuration for scanning.
*
* \param scan Number of scan defined in the ADC.
*
* \return None
*
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_InitConfig
*
*******************************************************************************/
void ADC_InitConfig(const ADC_CONFIG_STRUCT *config)
{
	uint32 chNum;
    uint32 tmpRegVal;
	
    #if(0u != ADC_ANY_CONFIG_USES_FILTER)	        
    	if((config->miscConfig & ADC_MISC_CONFIG_FILTER_PRESENT_MSK) 
    	    == ADC_MISC_CONFIG_FILTER_PRESENT_MSK)
    	{
            ADC_intUabClock_SetFractionalDividerRegister(config->filterClkDivider, 0u);
            
    	}
    #endif /* ADC_ANY_CONFIG_USES_FILTER != 0u */
    #if (ADC_CLOCK_INTERNAL)
        ADC_intSarClock_SetFractionalDividerRegister(config->clkDivider, 0u);
        
    #endif /* ADC_CLOCK_INTERNAL */
    /* Init SAR and MUX registers */
	ADC_SAR_CTRL_REG = config->ctrl
   
	/* Enable the SAR internal pump when global pump is enabled */
    | (((ADC_PUMP_CTRL_REG & ADC_PUMP_CTRL_ENABLED) != 0u) 
    ? ADC_SAR_CTRL_BOOSTPUMP_EN_MSK : 0u);
	
	ADC_SAR_SAMPLE_CTRL_REG = config->sampleCtrl;
	ADC_SAR_RANGE_THRES_REG = config->rangeThres;	
	ADC_SAR_RANGE_COND_REG = config->rangeCond;
	ADC_SAR_SAMPLE_TIME01_REG = config->sampleTime01;
	ADC_SAR_SAMPLE_TIME23_REG = config->sampleTime23;
    
	/* Connect Vminus to VSSA when even one channel is single-ended or multiple channels configured */
	if(1u == ADC_MUX_SWITCH0_INIT)
	{
		ADC_MUX_SWITCH0_REG |= ADC_MUX_FW_VSSA_VMINUS;
		/* Set MUX_HW_CTRL_VSSA in MUX_SWITCH_HW_CTRL when multiple channels enabled */
		if(1ul < config->numChannels)
		{
			ADC_MUX_SWITCH_HW_CTRL_REG |= ADC_MUX_FW_VSSA_VMINUS;
		}
	}
    
	/* Clear and set interrupt masks */
	ADC_SAR_SATURATE_INTR_MASK_REG = 0u;
    ADC_SAR_RANGE_INTR_MASK_REG = 0u;	
	ADC_SAR_SATURATE_INTR_MASK_REG = config->satIntMask;
	ADC_SAR_RANGE_INTR_MASK_REG = config->rangeIntMask;
	ADC_SAR_INTR_MASK_REG = ADC_EOS_MASK;
    
	/* Double the non-overlap delay and latch enable time when using */
    /* internal reference without bypass cap */
    tmpRegVal = ADC_SAR_DFT_CTRL_REG;
	if(((config->ctrl & ADC__SAR_CTRL_VREF_BYP_AND_SEL_MSK) 
	    == ADC__INTERNAL1024) 
	    || ((config->ctrl & ADC__SAR_CTRL_VREF_BYP_AND_SEL_MSK) 
	    == ADC__INTERNALVREF))
	{
        tmpRegVal &= ~ADC_SAR_DFT_CTRL_DCEN_MSK;
		tmpRegVal |= ADC_SAR_DFT_CTRL_DLY_INC_MSK;
	}
	else
	{
		tmpRegVal |= ADC_SAR_DFT_CTRL_DCEN_MSK;
        tmpRegVal &= (uint32)~ADC_SAR_DFT_CTRL_DLY_INC_MSK;
	}	
	ADC_SAR_DFT_CTRL_REG = tmpRegVal;
	
	for(chNum = 0u; chNum < config->numChannels; chNum++)
    {
		tmpRegVal = (ADC_channelsConfig[config->channelBase + chNum] 
		& ADC_CHANNEL_CONFIG_MASK);
        
        #if(ADC_TOTAL_CHANNELS_NUM > 1)
            tmpRegVal |= ADC_InputsPlacement[config->channelBase + chNum];
            /*Non-paired differential channels set NEG_ADDR_EN and clear DIFFERENTIAL_EN */
            if(0u != (ADC_InputsPlacement[config->channelBase + chNum] & ADC_CHANNEL_CONFIG_NEG_ADDR_EN_MSK))
            {
                tmpRegVal &= ~ADC_SAR_CHAN_CONFIG_DIFFERENTIAL_EN_MSK;
            }
        #endif
        
		CY_SET_REG32((reg32 *)(ADC_SAR_CHAN_CONFIG_IND + (uint32)(chNum << 2)), tmpRegVal);
	}
	
    return;
}

/* ****************************************************************************
* Function Name: ADC_SelectConfig
****************************************************************************//* 
*
* \brief Selects the predefined configuration for scanning. Disables
* and re-enables the SAR and filter (if filter used).
* 
* \param config Number of configuration  in the ADC.
* 
* \param restart Determines if the ADC should be  restarted after 
* selecting the configuration.
**
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SelectConfig
*
*******************************************************************************/
void ADC_SelectConfig(uint32 config, uint32 restart)
{
    /* Check whether the configuration number is valid or not */
    if(ADC_TOTAL_CONFIGS > config)
    {        
        /* Stop the ADC before changing configurations */
	    ADC_Stop();
        ADC_selected = 1u;
        
    	if(0u == ADC_initVar)
    	{
            ADC_Init();
            ADC_initVar |= ADC_INIT_VAR_INIT_FLAG;
    	}
        #if (ADC_VREF_ROUTED)
            ADC_vrefAMux_DisconnectAll();
        #endif
    	ADC_InitConfig(&ADC_allConfigs[config]);
        #if (ADC_VREF_ROUTED)
            ADC_vrefAMux_Select((uint8)config);
        #endif
        #if(0u != ADC_ANY_CONFIG_USES_FILTER)
            ADC_filterVinMux_Select((uint8)config);
            ADC_filterInit(config);
        #endif
    	ADC_SAR_CHAN_EN_REG = ADC_allConfigs[config].chanEn;
    	ADC_SAR_RANGE_INTR_MASK_REG = ADC_allConfigs[config].rangeIntMask;
    	ADC_SAR_SATURATE_INTR_MASK_REG = ADC_allConfigs[config].satIntMask;
    	ADC_currentConfig = config;
        
        if(1u == restart)
        {
            /* Restart the ADC */    
            ADC_Start();
            
            /* Restart the scan */
            ADC_StartConvert();
        }
    }
    return;
}

/*******************************************************************************
* Function Name: ADC_StartConvert
****************************************************************************//**
*
* \brief In continuous mode, this API starts the conversion process and it runs 
* continuously. 

* In Single Shot mode, the function triggers a single scan and 
* every scan requires a call of this function. The mode is set with the 
* Sample Mode parameter in the customizer. The customizer setting can be 
* overridden at run time with the ADC_SetConvertMode() function.
* 
* \param None
* 
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_StartConvert
*
*******************************************************************************/
void ADC_StartConvert(void)
{
    /* CDT 243358 */
    #if(0u != ADC_ANY_CONFIG_USES_FILTER)
        ADC_Stop();
        ADC_Start();
    #endif
    
	/* Freerunning mode */
	if((ADC_SAR_SAMPLE_CTRL_REG 
		& ADC_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK) 
		== ADC_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK)
    {
		ADC_SAR_SAMPLE_CTRL_REG |= ADC_SAR_SAMPLE_CTRL_CONTINUOUS_MSK ;
	}
	else /* Firmware trigger */
	{
		ADC_SAR_START_CTRL_REG = ADC_SAR_START_CTRL_FW_TRIGGER_MSK;
	}
    
    return;
}

/*******************************************************************************
* Function Name: ADC_StopConvert
****************************************************************************//**
*
* \brief Forces the ADC to stop conversions. If a conversion is 
* currently executing, that conversion will complete, but no further conversions 
* will occur.
* 
* \param None
*
* \return None
*
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_StopConvert
*
*******************************************************************************/
void ADC_StopConvert(void)
{
    if((ADC_SAR_SAMPLE_CTRL_REG  
		& ADC_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK) 
		== ADC_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK)
	{
        ADC_SAR_SAMPLE_CTRL_REG &= ~ADC_SAR_SAMPLE_CTRL_CONTINUOUS_MSK;
        
        if((ADC_allConfigs[ADC_currentConfig].miscConfig 
            & ADC_MISC_CONFIG_FILTER_PRESENT_MSK) 
    	    == ADC_MISC_CONFIG_FILTER_PRESENT_MSK)
        {
            /* Re-synchronize the Filter if a filter is present */
            ADC_Stop();
            ADC_Start();
        }
	}
    
    return;
}
/*******************************************************************************
* Function Name: ADC_SetConvertMode
****************************************************************************//**
*
* \brief Sets the conversion mode to either Single-Shot or continuous. This 
* function overrides the settings applied in the customizer. Changing 
* configurations will restore the values set in the customizer.
*
* \param mode Sets the conversion mode. See table below for details.
* | Options                          | Description                             |
* | :------------------------------- | :-------------------------------------- |
* | ADC_SINGLE_SHOT     | Calling the ADC_StartConvert() function after setting mode this will trigger a single scan. Sets the SOC signal to be edge sensitive, each edge will trigger a single scan. |
* | ADC_CONTINUOUS      | Calling the ADC_StartConvert() function after setting this mode trigger continuous scanning. This mode sets the SOC signal to be level sensitive. The ADC will continuously scan while soc is active. |
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetConvertMode
*
*******************************************************************************/
void ADC_SetConvertMode(uint32 mode)
{
    if(ADC_CONTINUOUS == mode)
    {
        ADC_SAR_SAMPLE_CTRL_REG |= ADC_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK;       
    }
    else
    {
        ADC_SAR_SAMPLE_CTRL_REG &= ~ADC_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK;       
    }
}
/* ****************************************************************************
* Function Name: ADC_IRQ_Enable
****************************************************************************//*
*
* \brief Enables interrupts to occur at the end of a conversion. Global 
* interrupts must also be enabled for the ADC interrupts to occur.
*
* \param None
*
* \return None
*
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_IRQ_Enable
*
*******************************************************************************/


/* ****************************************************************************
* Function Name: ADC_IRQ_Disable
****************************************************************************//* 
*
* \brief Disables end of conversion interrupts. 
*
* \param None
* 
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_IRQ_Disable
*
*******************************************************************************/


/*******************************************************************************
* Function Name: ADC_SetEosMask
****************************************************************************//**
*
* \brief Sets of clears the End of Scan (EOS) interrupt mask. 
*
* \param mask 1 to set the mask, 0 to clear the mask.
*
* \return None
* 
* \sideeffect All other bits in the INTR register are cleared by this function.
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetEosMask
*
*******************************************************************************/
void ADC_SetEosMask(uint32 mask)
{
    ADC_SAR_INTR_MASK_REG = mask & ADC_EOS_MASK;
    
    return;
}

/* ****************************************************************************
* Function Name: ADC_SetChanMask
****************************************************************************//*
*
* \brief Sets enable/disable mask for all channels in current configuration.
*
*
* \param enableMask
*  Channel enable/disable mask.
*
* \sideeffect
*  None.
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetChanMask
*
*******************************************************************************/
void ADC_SetChanMask(uint32 enableMask)
{
    uint32 chanCount = ADC_allConfigs[ADC_currentConfig].numChannels;
    enableMask &= (uint32)((uint32)(1ul << chanCount) - 1ul);
    ADC_SAR_CHAN_EN_REG = enableMask;
    return;
}

/*******************************************************************************
* Function Name: ADC_IsEndConversion
****************************************************************************//**
*
* \brief Immediately returns the status of the conversion or does not return 
* (blocking) until the conversion completes, depending on the retMode parameter.
*
* \param retMode Check conversion return mode. See the following table for 
* options.
* | Options                              | Description                             |
* | :-------------------------------     | :-------------------------------------- |
* | ADC_RETURN_STATUS       | Immediately returns the conversion status for sequential channels. If the value returned is zero, the conversion is not complete, and this function should be retried until a nonzero result is returned. |
* | ADC_WAIT_FOR_RESULT     | Does not return a result until the ADC conversion of all sequential channels is complete. |
* | ADC_RETURN_STATUS_INJ   | Immediately returns the conversion status for the injection channel. If the value returned is zero, the conversion is not complete, and this function should be retried until a nonzero result is returned. |
* | ADC_WAIT_FOR_RESULT_INJ | Does not return a result until the ADC completes injection channel conversion. |
* 
* \return uint8: If a nonzero value is returned, the last conversion is complete. 
* If the returned value is zero, the ADC is still calculating the last result.
*
* \sideeffect This function reads the end of conversion status, and clears it afterward.
* 
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_IsEndConversion
*
*******************************************************************************/
uint32 ADC_IsEndConversion(uint32 retMode)
{
    uint32 endOfConversion = 0u;
    uint32 wdt = 0x3FFFFFFuL; /* Watchdog timer for blocking while loop */
    if((ADC_RETURN_STATUS == retMode) || (ADC_WAIT_FOR_RESULT == retMode))
    {
        do
        {
            endOfConversion = ADC_SAR_INTR_REG & ADC_EOS_MASK;
            wdt--;
        }while(((0u == endOfConversion) 
            && (((uint32) retMode & ADC_WAIT_FOR_RESULT) != 0u))
            && (0uL != wdt));

        if(0u != endOfConversion)
        {
            /* Clear EOS bit */
            ADC_SAR_INTR_REG = ADC_EOS_MASK;
        }
    }
    
    return endOfConversion;
}
 
/* ****************************************************************************
* Function Name: ADC_IsChannelSigned(uint32 chan)
****************************************************************************//*
*
* Determines if the provided channel is in signed format. 
*
* \param chan The ADC channel to check. 
*
* \return None
* 
* \sideeffect None
*
*
*******************************************************************************/
static int32 ADC_IsChannelSigned(uint32 chan)
{
    int32 isSigned = 0;
    uint32 chanConfig;
    
    chanConfig = CY_GET_REG32((reg32 *)(ADC_SAR_CHAN_CONFIG_IND + (uint32)(chan << 2u)));
    /* If differential mode */
    if(0u != (chanConfig & ADC_CHANNEL_CONFIG_DIFF_ALL_MSK))
    {
        /*If signed differential */
        if((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
            & ADC_SAR_SAMPLE_CTRL_DIFFERENTIAL_SIGNED_MSK) != 0u)
        {
            isSigned = 1;
        }
    }
    else
    {
        if((ADC_allConfigs[ADC_currentConfig].sampleCtrl
            & ADC_SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED_MSK) != 0u)
        {
            isSigned = 1;
        }
    }
    return isSigned;
}
/*******************************************************************************
* Function Name: ADC_GetResult16
****************************************************************************//**
*
* \brief Gets the data available in the channel result data register
*
* \param chan The ADC channel to read the result from. The first 
* channel is 0 and the injection channel if enabled is the number of valid 
* channels.
*
* \return Returns converted data as a signed 16-bit integer.
* 
* \sideeffect None
* 
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_GetResult16
*
*******************************************************************************/
int16 ADC_GetResult16(uint32 chan)
{
    uint32 adcResult;
    
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < ADC_allConfigs[ADC_currentConfig].numChannels);

    if(ADC_allConfigs[ADC_currentConfig].numChannels > chan)
    {   
        adcResult = CY_GET_REG32((reg32 *)(ADC_SAR_CHAN_RESULT_IND + (uint32)(chan << 2u))) &
            ADC_RESULT_MASK; 
    }
    else
    {
		adcResult = 0u;
    }
    
    return (int16) adcResult;
}

/*******************************************************************************
* Function Name: ADC_GetResult32
****************************************************************************//**
*
* \brief Gets the data available in the channel result data register. 
*
* \param chan The ADC channel to read the result from. The first 
* channel is 0 and the injection channel if enabled is the number of valid 
* channels.
*
* \return Returns converted data as a signed 32-bit integer.
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_GetResult32
*
*******************************************************************************/
int32 ADC_GetResult32(uint32 chan)
{
    uint32 adcResult;
    int16 adcResult16;
    int32 finalResult;
    
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < ADC_allConfigs[ADC_currentConfig].numChannels);

    if(ADC_allConfigs[ADC_currentConfig].numChannels > chan)
    {
        adcResult = CY_GET_REG32((reg32 *)(ADC_SAR_CHAN_RESULT_IND + (uint32)(chan << 2u))) &
            ADC_RESULT_MASK;
    }
    else
    {
        adcResult = 0u;
    }
    /* Sign extend if channel is signed format */
    if(ADC_IsChannelSigned(chan) == 1)
    {
        adcResult16 = (int16) adcResult;
        finalResult = (int32) adcResult16;
    }
    else
    {
        finalResult = (int32) adcResult;
    }
    return finalResult;
}

/*******************************************************************************
* Function Name: ADC_SetLowLimit
****************************************************************************//**
*
* \brief Sets the low limit parameter for a limit condition.
*
* \param lowLimit The low limit for a limit condition.
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetLowLimit
*
*******************************************************************************/
void ADC_SetLowLimit(uint32 lowLimit)
{   
    ADC_SAR_RANGE_THRES_REG &= ~(uint32)(ADC_SAR_RANGE_THRES_RANGE_LOW_MSK);
    ADC_SAR_RANGE_THRES_REG |= lowLimit & ADC_SAR_RANGE_THRES_RANGE_LOW_MSK;
    return;
}

/*******************************************************************************
* Function Name: ADC_SetHighLimit
****************************************************************************//**
*
* \brief Sets the high limit parameter for a limit condition.
*
* \param highLimit The high limit for a limit condition.
*
* \return None
* 
* \sideeffect None
* 
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetHighLimit
*
*******************************************************************************/
void ADC_SetHighLimit(uint32 highLimit)
{   
    ADC_SAR_RANGE_THRES_REG &= ~(uint32)(ADC_SAR_RANGE_THRES_RANGE_HIGH_MSK);
    ADC_SAR_RANGE_THRES_REG |= (uint32)(highLimit << ADC_SAR_RANGE_THRES_RANGE_HIGH_SHFT);
    return;
}

/*******************************************************************************
* Function Name: ADC_SetLimitMask
****************************************************************************//**
*
* \brief Sets the channel limit condition mask.
*
*
* \param limitMask Sets which channels that may cause a limit condition interrupt. 
* Setting bits for channels that do not exist will have no effect. For example, 
* if only 6  channels were enabled, setting a mask of 0x0103 would only enable 
* the last two channels (0 and 1).
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetLimitMask
*
*******************************************************************************/
void ADC_SetLimitMask(uint32 limitMask)
{   
    uint32 chanCount = ADC_allConfigs[ADC_currentConfig].numChannels;
    limitMask &= (uint32)((uint32)(1ul << chanCount) - 1ul);
    ADC_SAR_RANGE_INTR_MASK_REG = limitMask;
    return;
}

/*******************************************************************************
* Function Name: ADC_SetSatMask
****************************************************************************//**
*
* \brief Sets the channel saturation event mask.
*
* \param satMask Sets which channels that may cause a saturation event interrupt. 
* Setting bits for channels that do not exist will have no effect. For example, 
* if only 8 channels were enabled, setting a mask of 0x01C0 would only enable two 
* channels (6 and 7).
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetSatMask
*
*******************************************************************************/
void ADC_SetSatMask(uint32 satMask)
{   
    uint32 chanCount = ADC_allConfigs[ADC_currentConfig].numChannels;
    satMask &= (uint32)((uint32)(1ul << chanCount) - 1ul);
    ADC_SAR_SATURATE_INTR_MASK_REG = satMask;    
    return;
}

/*******************************************************************************
* Function Name: ADC_SetOffset
****************************************************************************//**
*
* \brief Sets the ADC offset that is used by the functions ADC_CountsTo_uVolts, 
* ADC_CountsTo_mVolts, and ADC_CountsTo_Volts.
* 
* Offset is applied to counts before unit scaling and gain.  All CountsTo_[mV, uV, V]olts()
* functions use the following equation:
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* See CountsTo_Volts() for more about this formula.
* 
* To set channel 0's offset based on known V_offset_mV, use:
*     ADC_SetOffset(0uL, -1 * V_offset_mV * (1uL << (Resolution - 1)) / V_ref_mV);
*
* \param chan ADC channel number. 
* 
* \param offset This value is a measured value when the inputs are shorted or 
* connected to the same input voltage.
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetOffset
*
*******************************************************************************/
void ADC_SetOffset(uint32 chan, int16 offset)
{   
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < ADC_allConfigs[ADC_currentConfig].numChannels);

    ADC_offset[ADC_allConfigs[ADC_currentConfig].channelBase + chan] = offset;
    return;
}

/*******************************************************************************
* Function Name: ADC_SetGain
****************************************************************************//**
*
* \brief Sets the ADC gain in counts per 10 volt for the voltage 
* conversion functions. This value is set by default by the reference and 
* input range settings. Gain is applied after offset and unit scaling.  All 
* CountsTo_[mV, uV, V]olts() functions use the following equation:
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* See CountsTo_Volts() for more about this formula.
* 
* To set channel 0's gain based on known V_ref_mV, use:
*     ADC_SetGain(0uL, 10000 * (1uL << (Resolution - 1)) / V_ref_mV);
*  
* \param chan ADC channel number.
* 
* \param adcGain ADC gain in counts per 10 volt.
*
* \return None
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_SetGain
*
*******************************************************************************/
void ADC_SetGain(uint32 chan, int32 adcGain)
{   
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < ADC_allConfigs[ADC_currentConfig].numChannels);

    ADC_countsPer10Volt[ADC_allConfigs[ADC_currentConfig].channelBase + chan]
	= adcGain;
    return;
}
/*******************************************************************************
* Function Name: ADC_RawCounts2Counts
****************************************************************************//**
*
* \brief Converts the output of the SAR to an idealized count value.
*
* Divides by averaging amount, if needed, and subtracts offset.
*
* \param chan ADC channel number.   
*
* \param adcCounts Result from the ADC conversion.
*
* \return Averaged and offset counts.
* 
* \sideeffect None
*******************************************************************************/
int16 ADC_RawCounts2Counts(uint32 chan, int16 adcCounts)
{
    uint32 temp;
	uint32 averageAdcSamplesDiv;
	uint32 rawChannel;
	rawChannel = ADC_allConfigs[ADC_currentConfig].channelBase + chan;
	
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < ADC_allConfigs[ADC_currentConfig].numChannels);

    /* Divide the adcCount when accumulate averaging mode selected */
    /* If Average mode != fixed */
	if((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
		& ADC_SAR_SAMPLE_CTRL_AVG_SHIFT_MSK) 
		!= ADC_SAR_SAMPLE_CTRL_AVG_SHIFT_MSK)
	{
        /* If Channel uses averaging */
        if((ADC_channelsConfig[rawChannel] & ADC_SAR_CHAN_CONFIG_AVG_EN_MSK) != 0u)
        {
            /* Divide by 2^(AVG_CNT + 1) */
			averageAdcSamplesDiv = ((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
				& ADC_SAR_SAMPLE_CTRL_AVG_CNT_MSK) 
				>> ADC_SAR_SAMPLE_CTRL_AVG_CNT_SHFT);
            averageAdcSamplesDiv = (1uL << (averageAdcSamplesDiv + 1uL));
                        /* When it's "Sequential, Sum", divider limit is 16 */
            /* If Mode is ACCUNDUMP */
            if((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
    			& ADC_SAR_SAMPLE_CTRL_AVG_MODE_MSK) 
    			!= ADC_SAR_SAMPLE_CTRL_AVG_MODE_MSK)
    		{
                if (averageAdcSamplesDiv > 16uL)
                {
                    averageAdcSamplesDiv = 16uL;
                }
            }
            /* If unsigned format, prevent sign extension */
            if(0 == ADC_IsChannelSigned(chan))
            {
				temp = ((uint16) adcCounts / averageAdcSamplesDiv);
                adcCounts = (int16) temp;
            }
            else
            {
                adcCounts /= (int16) averageAdcSamplesDiv;
            }
        }
    }
    /* Subtract ADC offset */
    adcCounts -= ADC_offset[rawChannel];
    return adcCounts;
}

/*******************************************************************************
* Function Name: ADC_CountsTo_Volts
****************************************************************************//**
*
* \brief Converts the ADC output to Volts as a float32. For example, if the ADC 
* measured 0.534 volts, the return value would be 0.534.
* The calculation of voltage depends on the contents of ADC_offset[],
* ADC_countsPer10Volt[], and other parameters.  The equation used is:
* 
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* -Counts = Raw Counts from SAR register
* -AvgDivider = divider based on averaging mode
*     -Sequential, Sum: AvgDivider = number averaged
*         Note: The divider should be a maximum of 16. If using more averages, 
*         pre-scale Counts by (number averaged / 16)
*     -Interleaved, Sum: AvgDivider = number averaged
*     -Sequential, Fixed: AvgDivider = 1
* -Offset = ADC_offset[]
* -TEN_VOLT = 10V constant and unit scalar.
* -Gain = ADC_countsPer10Volt[]
* 
* When the Vref is based on Vdda, the value used for Vdda is set for the project
* in the System tab of the DWR.
*
* \param chan ADC channel number.   
*
* \param adcCounts Result from the ADC conversion.
*
* \return Result in Volts.
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_CountsTo_Volts
*
*******************************************************************************/
float32 ADC_CountsTo_Volts(uint32 chan, int16 adcCounts)
{   
    float32 result_Volts = 0.0f;
	uint32 rawChannel;
	rawChannel = ADC_allConfigs[ADC_currentConfig].channelBase + chan;
	
	if((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
		& ADC_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK) 
		!= ADC_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
	{
        adcCounts = ADC_RawCounts2Counts(chan, adcCounts);

        result_Volts = ((float32)adcCounts * ADC_10V_COUNTS) 
			/ (float32)ADC_countsPer10Volt[rawChannel];
	}
	return result_Volts;
}

/*******************************************************************************
* Function Name: ADC_CountsTo_mVolts
****************************************************************************//**
*
* \brief Converts the ADC output to millivolts as an int16. For example, if the ADC 
* measured 0.534 volts, the return value would be 534.
* The calculation of voltage depends on the contents of ADC_offset[],
* ADC_countsPer10Volt[], and other parameters.  The equation used is:
* 
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* -Counts = Raw Counts from SAR register
* -AvgDivider = divider based on averaging mode
*     -Sequential, Sum: AvgDivider = number averaged
*         Note: The divider should be a maximum of 16. If using more averages, 
*         pre-scale Counts by (number averaged / 16)
*     -Interleaved, Sum: AvgDivider = number averaged
*     -Sequential, Fixed: AvgDivider = 1
* -Offset = ADC_offset[]
* -TEN_VOLT = 10V constant and unit scalar.
* -Gain = ADC_countsPer10Volt[]
* 
* When the Vref is based on Vdda, the value used for Vdda is set for the project
* in the System tab of the DWR.
*
* \param chan ADC channel number. 
*
* \param adcCounts Result from the ADC conversion.
* 
* \return Result in mV.
* 
* \sideeffect None.
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_CountsTo_mVolts
*
*******************************************************************************/
int16 ADC_CountsTo_mVolts(uint32 chan, int16 adcCounts)
{   
    int16 result_mVolts = 0;
	uint32 rawChannel;
    
	rawChannel = ADC_allConfigs[ADC_currentConfig].channelBase + chan;
	
	if((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
		& ADC_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK) 
		!= ADC_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
	{
        adcCounts = ADC_RawCounts2Counts(chan, adcCounts);

	    result_mVolts = (int16)((((int32)adcCounts * ADC_10MV_COUNTS) + ( (adcCounts > 0) ? 
	             (ADC_countsPer10Volt[rawChannel] / 2) 
				: (-(ADC_countsPer10Volt[rawChannel] / 2)) )) 
	             / ADC_countsPer10Volt[rawChannel]);
	}
    return result_mVolts;
}

/*******************************************************************************
* Function Name: ADC_CountsTo_uVolts
****************************************************************************//**
*
* \brief Converts the ADC output to microvolts as an int32. For example, if the ADC 
* measured 0.534 volts, the return value would be 534000.
* The calculation of voltage depends on the contents of ADC_offset[],
* ADC_countsPer10Volt[], and other parameters.  The equation used is:
* 
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* -Counts = Raw Counts from SAR register
* -AvgDivider = divider based on averaging mode
*     -Sequential, Sum: AvgDivider = number averaged
*         Note: The divider should be a maximum of 16. If using more averages, 
*         pre-scale Counts by (number averaged / 16)
*     -Interleaved, Sum: AvgDivider = number averaged
*     -Sequential, Fixed: AvgDivider = 1
* -Offset = ADC_offset[]
* -TEN_VOLT = 10V constant and unit scalar.
* -Gain = ADC_countsPer10Volt[]
* 
* When the Vref is based on Vdda, the value used for Vdda is set for the project
* in the System tab of the DWR.
*
* \param chan ADC channel number.   
*
* \param adcCounts Result from the ADC conversion.
*
* \return Result in microvolts.
* 
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_CountsTo_uVolts
*
*******************************************************************************/
int32 ADC_CountsTo_uVolts(uint32 chan, int16 adcCounts)
{   
    int64 result_uVolts = 0;
	uint32 rawChannel;
	rawChannel = ADC_allConfigs[ADC_currentConfig].channelBase + chan;

	if((ADC_allConfigs[ADC_currentConfig].sampleCtrl 
		& ADC_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK) 
		!= ADC_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
	{
        adcCounts = ADC_RawCounts2Counts(chan, adcCounts);

        result_uVolts = ((int64)adcCounts * ADC_10UV_COUNTS) 
			/ ADC_countsPer10Volt[rawChannel];
	}
	return ( (int32)result_uVolts );
}

#if(0u != ADC_ANY_CONFIG_USES_FILTER)
    
    /* ****************************************************************************
    * Function Name: ADC_TrimFilterVos
    ****************************************************************************//*
    *
    * \brief Runs an algorithm to reduce voltage offset using the UAB's opamp trim.
    *
    * \param None
    * 
    * \return None
    *
    * \sideeffect None
    *
    * <b>Code Snippet</b>
    *  \snippet main.c snippet_ADC_TrimFilterVos
    *
    *******************************************************************************/
    void ADC_TrimFilterVos(void)
    {
        uint32 opampTrim = 0uL;
        uint32 agndTrim = 0uL;
        uint32 compStatus = 0uL;
        
        ADC_SetupComparatorTrim();
        
        /* Sweep from center to crossing */
        compStatus = ADC_SetOpampAndAgndTrim(ADC_OPAMP_TRIM_POS_BASE, ADC_AGND_TRIM_POS_BASE);
        if (0uL == compStatus)
        {
            opampTrim = ADC_RaiseOpampTrimToCrossing(ADC_OPAMP_TRIM_POS_BASE);
            agndTrim = ADC_RaiseAgndTrimToCrossing(ADC_AGND_TRIM_POS_BASE);
            if ((agndTrim == (ADC_AGND_TRIM_POS_LIMIT - 1uL))
                && (opampTrim != (ADC_OPAMP_TRIM_POS_LIMIT - 1uL)))
            {
                opampTrim = ADC_IncOpampTrim(opampTrim);
                (void) ADC_SetOpampAndAgndTrim(opampTrim, ADC_AGND_TRIM_POS_BASE);
                (void) ADC_LowerAgndTrimToCrossing(ADC_AGND_TRIM_POS_BASE);
            }
        }
        else
        {
            opampTrim = ADC_LowerOpampTrimToCrossing(ADC_OPAMP_TRIM_POS_BASE);
            agndTrim = ADC_LowerAgndTrimToCrossing(ADC_AGND_TRIM_POS_BASE);
            if ((agndTrim == (ADC_AGND_TRIM_NEG_LIMIT - 1uL))
                && (opampTrim != (ADC_OPAMP_TRIM_NEG_LIMIT - 1uL)))
            {
                opampTrim = ADC_DecOpampTrim(opampTrim);
                (void) ADC_SetOpampAndAgndTrim(opampTrim, ADC_AGND_TRIM_POS_BASE);
                (void) ADC_RaiseAgndTrimToCrossing(ADC_AGND_TRIM_POS_BASE);
            }
        }
        
        ADC_UndoComparatorTrimSetup();
    }
    
    
    static void ADC_SetupComparatorTrim(void)
    {
        /* Set firmware modbit. */
        ADC_UABH_A_CAP_ABCF_VAL_REG |= (0x1uL << CyUAB_SIGN_VAL_SHIFT);
        ADC_UABH_B_CAP_ABCF_VAL_REG |= (0x1uL << CyUAB_SIGN_VAL_SHIFT);
        
        /* Open filter output switch to isolate filter during trim. */
        ADC_UABH_B_SW_CF_BOT_REG &= ~(uint32)(ADC_UABH_B_SW_PO_MASK);
        
        /* Power on the UAB half B reference buffer. */
        ADC_UABH_B_OA_CTRL_REG |= (uint32)ADC_UABH_B_REF_PWR_MASK;
        
        /* Connect the UAB half B reference buffer to the comparator. */
        ADC_UABH_B_SW_STATIC_REG |= (uint32)ADC_UABH_B_SW_RT_MASK;
                        
        /* Clock the UAB half B comparator with phi1. */
        ADC_UABH_B_SW_OTHER_REG &= ~(uint32)ADC_UABH_B_CMP_FF_MASK;
        ADC_UABH_B_SW_OTHER_REG |= (uint32)((uint32)CyUAB_CLK_PHI1 << ADC_UABH_B_CMP_FF_SHIFT);
        
        /* Power on the UAB half B comparator. */
        ADC_UABH_B_OA_CTRL_REG |= (uint32)ADC_UABH_B_CMP_PWR_MASK;
    }
    
    
    static void ADC_UndoComparatorTrimSetup(void)
    {
        /* Power off the UAB half B comparator. */
        ADC_UABH_B_OA_CTRL_REG &= ~(uint32)ADC_UABH_B_CMP_PWR_MASK;
        
        /* Remove clock from the UAB half B comparator. */
        ADC_UABH_B_SW_OTHER_REG &= ~(uint32)ADC_UABH_B_CMP_FF_MASK;
        ADC_UABH_B_SW_OTHER_REG |= (uint32)((uint32)CyUAB_SW_OPEN << ADC_UABH_B_CMP_FF_SHIFT);
        
        /* Disconnect the UAB half B reference buffer from the comparator. */
        ADC_UABH_B_SW_STATIC_REG &= ~(uint32)ADC_UABH_B_SW_RT_MASK;
                        
        /* Power off the UAB half B reference buffer. */
        ADC_UABH_B_OA_CTRL_REG &= ~(uint32)ADC_UABH_B_REF_PWR_MASK;
        
        /* Close filter output switch to connect filter to AROUTE. */
        ADC_UABH_B_SW_CF_BOT_REG &= ~(uint32)(ADC_UABH_B_SW_PO_MASK);
        ADC_UABH_B_SW_CF_BOT_REG |= (uint32)((uint32)CyUAB_CLK_PHI3 << ADC_UABH_B_SW_PO_SHIFT);
        
        /* Clear the modbit */
        ADC_UABH_A_CAP_ABCF_VAL_REG &= ~(0x1uL << CyUAB_SIGN_VAL_SHIFT);
        ADC_UABH_B_CAP_ABCF_VAL_REG &= ~(0x1uL << CyUAB_SIGN_VAL_SHIFT);
    }
    
    
    static uint32 ADC_RaiseOpampTrimToCrossing(uint32 startTrim)
    {
        uint32 opampTrim;
        uint32 lastOpampTrim;
        uint32 compStatus;

        lastOpampTrim = startTrim;
        for (opampTrim = startTrim;
            opampTrim != ADC_OPAMP_TRIM_NEG_LIMIT;
            opampTrim = ADC_IncOpampTrim(opampTrim))
        {
            compStatus = ADC_SetOpampAndAgndTrim(opampTrim, ADC_AGND_TRIM_POS_BASE);
            if (0uL != compStatus)
            {
                (void) ADC_SetOpampTrim(lastOpampTrim);
                break;
            }
            lastOpampTrim = opampTrim;
        }
        
        return lastOpampTrim;
    }


    static uint32 ADC_LowerOpampTrimToCrossing(uint32 startTrim)
    {
        uint32 opampTrim;
        uint32 lastOpampTrim;
        uint32 compStatus;

        lastOpampTrim = startTrim;
        for (opampTrim = startTrim;
            opampTrim != ADC_OPAMP_TRIM_NEG_LIMIT;
            opampTrim = ADC_DecOpampTrim(opampTrim))
        {
            compStatus = ADC_SetOpampAndAgndTrim(opampTrim, ADC_AGND_TRIM_POS_BASE);
            if (0uL == compStatus)
            {
                (void) ADC_SetOpampTrim(lastOpampTrim);
                break;
            }
            lastOpampTrim = opampTrim;
        }
        
        return lastOpampTrim;
    }


    static uint32 ADC_RaiseAgndTrimToCrossing(uint32 startTrim)
    {
        uint32 agndTrim;
        uint32 lastAgndTrim;
        uint32 compStatus;

        lastAgndTrim = startTrim;
        for (agndTrim = startTrim;
            agndTrim != ADC_AGND_TRIM_NEG_LIMIT;
            agndTrim = ADC_IncAgndTrim(agndTrim))
        {
            compStatus = ADC_SetAgndTrim(agndTrim);
            if (0uL != compStatus)
            {
                (void) ADC_SetAgndTrim(lastAgndTrim); 
                break;
            }
            lastAgndTrim = agndTrim;
        }
        
        return lastAgndTrim;
    }
    
    
    static uint32 ADC_LowerAgndTrimToCrossing(uint32 startTrim)
    {
        uint32 agndTrim = startTrim;
        uint32 lastAgndTrim = agndTrim;
        uint32 compStatus = 1uL;

        lastAgndTrim = startTrim;
        for (agndTrim = startTrim;
            agndTrim != ADC_AGND_TRIM_NEG_LIMIT;
            agndTrim = ADC_DecAgndTrim(agndTrim))
        {
            compStatus = ADC_SetAgndTrim(agndTrim);
            if (0uL == compStatus)
            {
                (void) ADC_SetAgndTrim(lastAgndTrim); 
                break;
            }
            lastAgndTrim = agndTrim;
        }
        
        return lastAgndTrim;
    }
    
    
    static uint32 ADC_SetOpampAndAgndTrim(uint32 opampTrim, uint32 agndTrim)
    {
        uint32 compStatus = 0uL;
 
        uint32 trimRegVal = ADC_UABH_A_OA_TRIM_REG;
        trimRegVal &= ~(ADC_OPAMP_TRIM_MASK << CyUAB_OA_OFFSET_SHIFT);
        trimRegVal |= (opampTrim << CyUAB_OA_OFFSET_SHIFT);
        trimRegVal &= ~(ADC_AGND_TRIM_MASK << CyUAB_AGND_OFFSET_SHIFT);
        trimRegVal |= (agndTrim << CyUAB_AGND_OFFSET_SHIFT);
        ADC_UABH_A_OA_TRIM_REG = trimRegVal;
        
        CyDelayUs(100u);
        
        compStatus = ADC_UABH_B_STAT_REG & ADC_UABH_B_COMP_MASK;
        
        return compStatus;
    }
    
    
    static uint32 ADC_SetOpampTrim(uint32 opampTrim)
    {
        uint32 compStatus = 0uL;
 
        uint32 trimRegVal = ADC_UABH_A_OA_TRIM_REG;
        trimRegVal &= ~(ADC_OPAMP_TRIM_MASK << CyUAB_OA_OFFSET_SHIFT);
        trimRegVal |= (opampTrim << CyUAB_OA_OFFSET_SHIFT);
        ADC_UABH_A_OA_TRIM_REG = trimRegVal;
        
        CyDelayUs(100u);
        
        compStatus = ADC_UABH_B_STAT_REG & ADC_UABH_B_COMP_MASK;
        
        return compStatus;
    }
    
    
    static uint32 ADC_SetAgndTrim(uint32 agndTrim)
    {
        uint32 compStatus = 0uL;
 
        uint32 trimRegVal = ADC_UABH_A_OA_TRIM_REG;
        trimRegVal &= ~(ADC_AGND_TRIM_MASK << CyUAB_AGND_OFFSET_SHIFT);
        trimRegVal |= (agndTrim << CyUAB_AGND_OFFSET_SHIFT);
        ADC_UABH_A_OA_TRIM_REG = trimRegVal;
        
        CyDelayUs(100u);
        
        compStatus = ADC_UABH_B_STAT_REG & ADC_UABH_B_COMP_MASK;
        
        return compStatus;
    }
    
    /* Skips OPAMP_TRIM_NEG_BASE because it is the same as POS_BASE. */
    static uint32 ADC_IncOpampTrim(uint32 trim)
    {
        
        if (trim < (ADC_OPAMP_TRIM_POS_LIMIT - 1uL))
        {
            trim = trim + 1uL;
        }
        else if ((ADC_OPAMP_TRIM_POS_LIMIT - 1uL) == trim)
        {
            trim = ADC_OPAMP_TRIM_NEG_LIMIT;
        }
        else if (trim <= (ADC_OPAMP_TRIM_NEG_BASE + 1uL))
        {
            trim = ADC_OPAMP_TRIM_POS_BASE;
        }
        else
        {
            trim = trim - 1uL;
        }
        
        return trim;
    }


    /* Skips OPAMP_TRIM_NEG_BASE because it is the same as POS_BASE. */
    static uint32 ADC_DecOpampTrim(uint32 trim)
    {
        
        if (ADC_OPAMP_TRIM_POS_BASE == trim)
        {
            trim = ADC_OPAMP_TRIM_NEG_BASE + 1uL;
        }
        else if (trim < ADC_OPAMP_TRIM_POS_LIMIT)
        {
            trim = trim - 1uL;
        }
        else if (trim < ADC_OPAMP_TRIM_NEG_LIMIT)
        {
            trim = trim + 1uL;
        }
        else
        {
            trim = ADC_OPAMP_TRIM_POS_LIMIT - 1uL;
        }
        
        return trim;
    }


    /* Skips AGND_TRIM_NEG_BASE because it is the same as POS_BASE. */
    static uint32 ADC_IncAgndTrim(uint32 trim)
    {
        
        if (trim < (ADC_AGND_TRIM_POS_LIMIT - 1uL))
        {
            trim = trim + 1uL;
        }
        else if ((ADC_AGND_TRIM_POS_LIMIT - 1uL) == trim)
        {
            trim = ADC_AGND_TRIM_NEG_LIMIT;
        }
        else if (trim <= (ADC_AGND_TRIM_NEG_BASE + 1uL))
        {
            trim = ADC_AGND_TRIM_POS_BASE;
        }
        else
        {
            trim = trim - 1uL;
        }
        
        return trim;
    }


    /* Skips ADC_AGND_TRIM_NEG_BASE because it is the same as POS_BASE. */
    static uint32 ADC_DecAgndTrim(uint32 trim)
    {
        
        if (trim == ADC_AGND_TRIM_POS_BASE)
        {
            trim = ADC_AGND_TRIM_NEG_BASE + 1uL;
        }
        else if (trim < ADC_AGND_TRIM_POS_LIMIT)
        {
            trim = trim - 1uL;
        }
        else if (trim < ADC_AGND_TRIM_NEG_LIMIT)
        {
            trim = trim + 1uL;
        }
        else
        {
            trim = ADC_AGND_TRIM_POS_LIMIT - 1uL;
        }
        
        return trim;
    }

    
    void ADC_filterInit(uint32 configNum)
    {
        /* Configure the common filter settings if any configuration filters */
        switch (configNum)
        {
            #if (0u != ADC_CFG0_FILTER_PRESENT)
            case 0u:
    		    ADC_UABH_A_Init(&ADC_CFG0_UABH_A_FILTER_config);
    		    ADC_UABH_B_Init(&ADC_CFG0_UABH_B_FILTER_config);
                
            break;
            #endif
            #if (0u != ADC_CFG1_FILTER_PRESENT)
            case 1u:
    		    ADC_UABH_A_Init(&ADC_CFG1_UABH_A_FILTER_config);
    		    ADC_UABH_B_Init(&ADC_CFG1_UABH_B_FILTER_config);
                
            break;
            #endif
            #if (0u != ADC_CFG2_FILTER_PRESENT)
            case 2u:
    		    ADC_UABH_A_Init(&ADC_CFG2_UABH_A_FILTER_config);
    		    ADC_UABH_B_Init(&ADC_CFG2_UABH_B_FILTER_config);
                
            break;
            #endif
            #if (0u != ADC_CFG3_FILTER_PRESENT)
            case 3u:
    		    ADC_UABH_A_Init(&ADC_CFG3_UABH_A_FILTER_config);
    		    ADC_UABH_B_Init(&ADC_CFG3_UABH_B_FILTER_config);
                
            break;
            #endif
            default:
            break;
        }
        ADC_FILTERAGND2SAR_BUFFER_Init();
    }
#endif /* ADC_ANY_CONFIG_USES_FILTER != 0u */


/* ****************************************************************************
* Function Name: ADC_Init
****************************************************************************//*
*
* \brief Initialize the component according to parameters defined in the 
* customizer.
*
* \param None
* 
* \return None
*
* \sideeffect None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_Init
*
*******************************************************************************/
void ADC_Init(void)
{
	uint32 chNum = 0ul;
	uint32 configNum = 0u;
	int32 counts;
	
	if(0u == ADC_initVar)
	{
		/* Set offset and countsPer10Volt for all channels */
		for(chNum = 0ul; chNum < ADC_TOTAL_CHANNELS_NUM; chNum++)
		{      
			if((ADC_channelsConfig[chNum] & ADC_SAR_CHAN_CONFIG_RESOLUTION_MSK) != 0u)
        	{
				if((ADC_allConfigs[configNum].sampleCtrl 
					& ADC_SAR_SAMPLE_CTRL_SUB_RESOLUTION_MSK) 
					== ADC_SUB_RESOLUTION_10B)
				{
					counts = (int32) ADC_SAR_WRK_MAX_10BIT;
				}
				else
				{
					counts = (int32) ADC_SAR_WRK_MAX_8BIT;
				}
        	}
        	else
        	{
               counts = (int32)ADC_SAR_WRK_MAX_12BIT;
        	}
			
			/* Single Ended Channel */
			if((ADC_channelsConfig[chNum] & ADC_SAR_CHAN_CONFIG_DIFFERENTIAL_EN_MSK) == 0u)
        	{
				if(((ADC_allConfigs[configNum].sampleCtrl 
					& ADC_SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED_MSK) 
					== ADC_SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED_MSK) && 
					((ADC_allConfigs[configNum].ctrl & ADC_SAR_CTRL_NEG_SEL_MSK) 
					== ADC_NEG_VREF_SHIFTED))
				{
					/* Set offset to the minus half scale to convert results to unsigned format */
                	ADC_offset[chNum] = (int16)(counts / -2);		
            	}
				else
				{
                	ADC_offset[chNum] = 0;	
				}
				
			}
			else    /* Differential channel */
        	{
               	ADC_offset[chNum] = 0; 
			}
            
			/* Calculate gain in counts per 10 volts with rounding */
        	ADC_countsPer10Volt[chNum] = (int16)(((counts * ADC_10MV_COUNTS) \
                            + ADC_allConfigs[configNum].vrefMvValue) \
							/ (ADC_allConfigs[configNum].vrefMvValue * 2));
            
            /* Increment configuration number after rolling over to the next configuration*/
			if((ADC_allConfigs[configNum].channelBase
				+ (ADC_allConfigs[configNum].numChannels - 1uL)) == chNum)
			{
				configNum++;
			}
		} /* for(chNum = 0ul; chNum < ADC_TOTAL_CHANNELS_NUM; chNum++) */
        
        #if(ADC_IRQ_REMOVE == 0u)
            /* Start and set interrupt vector */
            CyIntSetPriority(ADC_INTC_NUMBER, ADC_INTC_PRIOR_NUMBER);
            (void)CyIntSetVector(ADC_INTC_NUMBER, &ADC_ISR);
        #endif   /* End ADC_IRQ_REMOVE */
        
        /* Initialize configuration zero if SelectConfig has not been called */
        if(0u == ADC_selected)
	    {
            ADC_selected = 1u;
            configNum = 0u;
            /* Change Vref selection if is was routed by Creator. Break. */
            #if (ADC_VREF_ROUTED)
                ADC_vrefAMux_DisconnectAll();
            #endif
            ADC_InitConfig(&ADC_allConfigs[configNum]);
            /* Change Vref selection if is was routed by Creator. Make. */
            #if (ADC_VREF_ROUTED)
                ADC_vrefAMux_Select((uint8)configNum);
            #endif
            ADC_SAR_CHAN_EN_REG = ADC_allConfigs[configNum].chanEn;
            #if(0u != ADC_ANY_CONFIG_USES_FILTER)	
                ADC_filterVinMux_Select((uint8)configNum);
                ADC_filterInit(configNum);
            #endif
        }           
	}
    return;
}


/* ****************************************************************************
* Function Name: ADC_Enable
****************************************************************************//*
*
* \brief Enables the component. 
*
* \param None
* 
* \return None
* 
* \sideeffect
*  None
*
* <b>Code Snippet</b>
*  \snippet main.c snippet_ADC_Enable
*
*******************************************************************************/
void ADC_Enable(void) 
{

    #if(0u != ADC_ANY_CONFIG_USES_FILTER)	
    	if((ADC_allConfigs[ADC_currentConfig].miscConfig
    		& ADC_MISC_CONFIG_FILTER_PRESENT_MSK)
    		== ADC_MISC_CONFIG_FILTER_PRESENT_MSK)
    	{
            ADC_FILTERAGND2SAR_BUFFER_Enable();
    		ADC_UABH_A_Enable();
    		ADC_UABH_B_Enable();
            ADC_UABH_B_Run(1u);
            ADC_UABH_A_Run(1u);
    	}
    #endif /* ADC_ANY_CONFIG_USES_FILTER != 0u */
        
    if (0u == (ADC_SAR_CTRL_REG & ADC_SAR_CTRL_ENABLED_MSK))
    {
        while (0u != (ADC_SAR_STATUS_REG & ADC_BUSY_MSK))
        {
            /* wait for SAR to go idle to avoid deadlock */
        }
        
        ADC_SAR_CTRL_REG |= ADC_SAR_CTRL_ENABLED_MSK;
        
        /* The block is ready to use 10 us after the enable signal is set high. */
        CyDelayUs(ADC_10US_DELAY);
    }
    return;
}


/* [] END OF FILE */
